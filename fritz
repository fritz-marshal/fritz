#!/usr/bin/env python
import argparse
from contextlib import contextmanager
import json
import os
from pathlib import Path
import subprocess
import sys


@contextmanager
def status(message):
    # stolen from baselayer
    print(f'[¬∑] {message}', end='')
    try:
        yield
    except:
        print(f'\r[‚úó] {message}')
        raise
    else:
        print(f'\r[‚úì] {message}')


def check_configs(cfgs):
    # use config defaults if configs do not exist
    for cfg in cfgs:
        # cwd = str(Path(cfg).parent)
        c = cfg.replace('.defaults', '')
        if not Path(c).exists():
            cd = input(f'{c} does not exist, do you want to use {cfg} (not recommended)? [y/N] ')
            # print(cd, cd.lower() == 'y')
            if cd.lower() == 'y':
                s = subprocess.run(["cp", f"{cfg}", f"{c}"])
                if s.returncode != 0:
                    raise IOError(f"Failed to copy {cfg} to {c}")
            else:
                raise IOError(f'{c} does not exist, aborting')


def get_skyportal_token():
    """
    Get a token for Kowalski to access SkyPortal
    this is ugly and should be re-done, but gets the work done, so ok for now
    """
    result = subprocess.run(
        ["docker", "exec", "-it", "skyportal_web_1", "/bin/bash", "-c",
         "source /skyportal_env/bin/activate; "
         """python -c "from baselayer.app.config import load_config; """
         """from skyportal.models import init_db; """
         """from skyportal.model_util import create_token; """
         # """import secrets; import string; """
         """conn = init_db(**load_config(['config.yaml'])['database']); """
         # """token_name = ''.join(secrets.choice(string.ascii_lowercase) for _ in range(6)); """
         # """print(create_token(['Upload data', 'Manage sources'], 1, token_name))" """
         """print(create_token(['Upload data', 'Manage sources'], 1, 'kowalski'))" """
         ],
        cwd="skyportal",
        capture_output=True,
        universal_newlines=True,
    )
    token = result.stdout.split()[-1]

    if len(token) != 36:
        raise RuntimeError('Failed to generate a SkyPortal token for Kowalski')

    return token


def update_kowalski_secrets(token):

    p_secrets = Path('kowalski/secrets.json')

    if not p_secrets.exists():
        raise IOError(f'{p_secrets} does not exist')

    with open(str(p_secrets), 'r') as f:
        secrets = json.load(f)
    secrets['skyportal']['token'] = token

    with open(str(p_secrets), 'w') as f:
        json.dump(secrets, f, indent=2)


def run(args):
    """
    Launch Fritz
    """
    env = os.environ.copy()
    env.update({"FLAGS": "--config=../fritz.yaml"})

    if args.init:
        # pull skyportal and kowalski
        p = subprocess.run(['git', 'submodule', 'update', '--init'])
        if p.returncode != 0:
            raise RuntimeError("Failed to initialize fritz's submodules")
        p = subprocess.run(['git', 'submodule', 'update'])
        if p.returncode != 0:
            raise RuntimeError("Failed to update fritz's submodules")
        # pass
    else:
        p = subprocess.run(['git', 'submodule', 'update'])
        if p.returncode != 0:
            raise RuntimeError("Failed to update fritz's submodules")
        # pass

    if args.init:
        # Build skyportal's images
        # check skyportal configs:
        cfgs = ('skyportal/config.yaml.defaults', 'skyportal/docker.yaml.defaults')
        check_configs(cfgs)
        p = subprocess.run(["make", "docker-local"], cwd="skyportal")
        if p.returncode != 0:
            raise RuntimeError("Failed to build skyportal's docker images")
        # subprocess.run(["make", "db_init"], cwd="skyportal", env=env)

    # start up skyportal
    # subprocess.run(["make", "run"], cwd="skyportal", env=env)
    # check configs:
    # cfgs = ('skyportal/docker-compose.yaml.defaults', )
    # check_configs(cfgs)
    p = subprocess.run(["docker-compose", "up", "-d"], cwd="skyportal")
    if p.returncode != 0:
        raise RuntimeError("Failed to start skyportal")

    if args.init:
        # init skyportal and load test data
        p = subprocess.run(["docker", "exec", "-it", "skyportal_web_1", "/bin/bash", "-c",
                            "source /skyportal_env/bin/activate; make load_demo_data"], cwd="skyportal")
        if p.returncode != 0:
            raise RuntimeError("Failed to init skyportal and load test data")

        # create the kowalski user and write access token to kowalski/secrets.json
        token = get_skyportal_token()
        # check that Kowalski's secrets.json exist:
        cfgs = ('kowalski/secrets.defaults.json', )
        check_configs(cfgs)
        # update kowalski's secrets.json with the generated token:
        update_kowalski_secrets(token)

        # Build kowalski's images
        p = subprocess.run(["python", "kowalski.py", "build", "--fritz"], cwd="kowalski")
        if p.returncode != 0:
            raise RuntimeError("Failed to build kowalski's docker images")

    # start up kowalski
    p = subprocess.run(["python", "kowalski.py", "up", "--fritz"], cwd="kowalski")
    if p.returncode != 0:
        raise RuntimeError("Failed to start kowalski")


def stop(args):
    """
        Shut marshal down
    :param args:
    :return:
    """
    print('Shutting fritz down...')
    # subprocess.run(["docker-compose", "down"], cwd="kowalski")
    p = subprocess.run(["python", "kowalski.py", "down", "--fritz"], cwd="kowalski")
    p = subprocess.run(["docker-compose", "down"], cwd="skyportal")


def log(args):
    """
    Show colorized logs while the marshal is running
    """
    p = subprocess.run(["make", "log"], cwd="skyportal")
    if p.returncode != 0:
        raise RuntimeError("Failed to display fritz's logs")


def develop(args=None):
    """
    Install developer tools.
    """
    p = subprocess.run(["pip", "install", "-r", ".requirements/dev.txt"])
    p = subprocess.run(["pre-commit", "install"])


def lint(args):
    try:
        import pre_commit  # noqa: F401
    except ImportError:
        develop()

    p = subprocess.run(["pre-commit", "run", "--all-files"])


def prune(args=None):
    """
    todo: Prune fritz'es docker containers and volumes and reset configs to defaults
    """
    # are you sure?
    go = input(f"Do you want to prune fritz'es docker containers and volumes and deinit submodules? [y/N] ")

    if go.lower() == 'y':
        # try stopping anything that's running first:
        stop(args)

        # remove docker images
        for image_name in ('kowalski_api', 'kowalski_ingester', 'skyportal/web'):
            p1 = subprocess.Popen(['docker', 'images'], stdout=subprocess.PIPE)
            p2 = subprocess.Popen(['grep', image_name], stdin=p1.stdout, stdout=subprocess.PIPE)
            image_id = subprocess.check_output(['awk', '{print $3}'], stdin=p2.stdout, universal_newlines=True).strip()
            p3 = subprocess.run(['docker', 'rmi', image_id])
            if p3.returncode == 0:
                print(f'Removed {image_name} docker image')
            else:
                print(f'Failed to removed {image_name} docker image')

        # remove docker volumes
        for volume_name in ('kowalski_data', 'kowalski_mongodb', 'skyportal_dbdata'):
            p = subprocess.run(['docker', 'volume', 'rm', volume_name])
            if p.returncode == 0:
                print(f'Removed {volume_name} docker volume')
            else:
                print(f'Failed to removed {volume_name} docker volume')

        # remove user configs
        # cfgs = (
        #     'skyportal/config.yaml',
        #     'kowalski/secrets.json',
        #     'kowalski/docker-compose.fritz.yaml',
        #     'kowalski/kowalski/config_api.json',
        #     'kowalski/kowalski/config_ingester.json',
        #     'kowalski/kowalski/supervisord_api.conf',
        #     'kowalski/kowalski/supervisord_ingester.conf',
        # )
        # for cfg in cfgs:
        #     p = subprocess.run(['rm', '-f', cfg])
        #     if p.returncode == 0:
        #         print(f'Removed {cfg} config file')
        #     else:
        #         print(f'Failed to removed {cfg} config file')

        # deinit submodules
        p = subprocess.run(['git', 'submodule', 'deinit', '--all', '-f'])
        if p.returncode == 0:
            print(f"Deinitialized fritz' submodules")
        else:
            print(f"Failed to deinit fritz' submodules")


def test(args):
    print("Launching tests...")

    # load_demo_data is run as part of ./fritz run --init since it is needed to create a token for kowalski

    print("Testing Kowalski...")
    p = subprocess.run(["python", "kowalski.py", "test"], cwd="kowalski")


def doc(args):
    subprocess.run(["make", "html"], cwd="doc")
    Path("doc/_build/html/.nojekyll").touch()

    if args.upload:
        subprocess.run(
            [
                "./tools/push_dir_to_repo.py",
                "--branch",
                "master",
                "--committer",
                "fritz",
                "--email",
                "fritz@fritz-marshal.org",
                "--message",
                "Update website",
                "--force",
                "./doc/_build/html",
                "git@github.com:fritz-marshal/doc",
            ]
        )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title="commands", dest="command")

    commands = [
        ("run", "üöÄ Launch Fritz"),
        ("stop", "‚úã Shut Fritz down"),
        ("test", "Run the test suite"),
        ("develop", "Install tools for developing Fritz"),
        ("lint", "Lint the full code base"),
        ("prune", "‚ò†Ô∏è Wipe out containers, volumes, and submodules"),
        ("doc", "Build the documentation"),
        ("help", "Print this message"),
    ]

    parsers = {}
    for (cmd, desc) in commands:
        parsers[cmd] = subparsers.add_parser(cmd, help=desc)

    parsers["run"].add_argument(
        "--init", action="store_true", help="Initialize Fritz"
    )

    parsers["doc"].add_argument(
        "--upload", action="store_true", help="Upload documentation to GitHub"
    )

    args = parser.parse_args()
    if args.command is None or args.command == "help":
        parser.print_help()
    else:
        getattr(sys.modules[__name__], args.command)(args)
