#!/usr/bin/env python
import argparse
from contextlib import contextmanager
import json
import os
from pathlib import Path
import subprocess
import sys


@contextmanager
def status(message):
    # from baselayer
    print(f'[¬∑] {message}', end='')
    try:
        yield
    except:  # noqa: E722
        print(f'\r[‚úó] {message}')
        raise
    else:
        print(f'\r[‚úì] {message}')


def check_configs(cfgs):
    # use config defaults if configs do not exist
    for cfg in cfgs:
        # cwd = str(Path(cfg).parent)
        c = cfg.replace('.defaults', '')
        if not Path(c).exists():
            cd = input(f'{c} does not exist, do you want to use {cfg} (not recommended)? [y/N] ')
            if cd.lower() == 'y':
                s = subprocess.run(["cp", f"{cfg}", f"{c}"])
                if s.returncode != 0:
                    raise IOError(f"Failed to copy {cfg} to {c}")
            else:
                raise IOError(f'{c} does not exist, aborting')


def get_skyportal_token():
    """
    Get a token for Kowalski to access SkyPortal
    this is ugly and should be re-done, but gets the work done, so ok for now
    """
    result = subprocess.run(
        ["docker", "exec", "-it", "skyportal_web_1", "/bin/bash", "-c",
         "source /skyportal_env/bin/activate; "
         """python -c "from baselayer.app.config import load_config; """
         """from skyportal.models import init_db; """
         """from skyportal.model_util import create_token; """
         """conn = init_db(**load_config(['config.yaml'])['database']); """
         """print(create_token(['Upload data', 'Manage sources'], 1, 'kowalski'))" """
         ],
        cwd="skyportal",
        capture_output=True,
        universal_newlines=True,
    )
    token = result.stdout.split()[-1]

    if len(token) != 36:
        raise RuntimeError('Failed to generate a SkyPortal token for Kowalski')

    return token


def update_kowalski_secrets(token):

    p_secrets = Path('kowalski/secrets.json')

    if not p_secrets.exists():
        raise IOError(f'{p_secrets} does not exist')

    with open(str(p_secrets), 'r') as f:
        secrets = json.load(f)
    secrets['skyportal']['token'] = token

    with open(str(p_secrets), 'w') as f:
        json.dump(secrets, f, indent=2)


def run(args):
    """
    Launch Fritz
    """
    env = os.environ.copy()
    env.update({"FLAGS": "--config=../fritz.yaml"})

    if args.init:
        # pull skyportal and kowalski
        p = subprocess.run(['git', 'submodule', 'update', '--init', '--recursive'])
        if p.returncode != 0:
            raise RuntimeError("Failed to initialize fritz's submodules")
        p = subprocess.run(['git', 'submodule', 'update'])
        if p.returncode != 0:
            raise RuntimeError("Failed to update fritz's submodules")
    else:
        p = subprocess.run(['git', 'submodule', 'update'])
        if p.returncode != 0:
            raise RuntimeError("Failed to update fritz's submodules")

    if args.init:
        # Build skyportal's images

        # Check skyportal configs:
        cfgs = ('skyportal/config.yaml.defaults', 'skyportal/docker.yaml.defaults')
        check_configs(cfgs)
        p = subprocess.run(["make", "docker-local"], cwd="skyportal")
        if p.returncode != 0:
            raise RuntimeError("Failed to build skyportal's docker images")

    # start up skyportal
    p = subprocess.run(["docker-compose", "up", "-d"], cwd="skyportal")
    if p.returncode != 0:
        raise RuntimeError("Failed to start skyportal")

    if args.init:
        # init skyportal and load test data
        p = subprocess.run(["docker", "exec", "-it", "skyportal_web_1", "/bin/bash", "-c",
                            "source /skyportal_env/bin/activate; make load_demo_data"], cwd="skyportal")
        if p.returncode != 0:
            raise RuntimeError("Failed to init skyportal and load test data")

        # create the kowalski user and write access token to kowalski/secrets.json
        token = get_skyportal_token()
        # check that Kowalski's secrets.json exist:
        cfgs = ('kowalski/secrets.defaults.json', )
        check_configs(cfgs)
        # update kowalski's secrets.json with the generated token:
        update_kowalski_secrets(token)

        # Build kowalski's images
        p = subprocess.run(["python", "kowalski.py", "build", "--fritz"], cwd="kowalski")
        if p.returncode != 0:
            raise RuntimeError("Failed to build kowalski's docker images")

    # start up kowalski
    p = subprocess.run(["python", "kowalski.py", "up", "--fritz"], cwd="kowalski")
    if p.returncode != 0:
        raise RuntimeError("Failed to start kowalski")


def stop(args):
    """
    Shut down Fritz
    """
    print('Shutting fritz down...')
    subprocess.run(["python", "kowalski.py", "down", "--fritz"], cwd="kowalski")
    subprocess.run(["docker-compose", "down"], cwd="skyportal")


def log(args):
    """
    Show colorized logs while the marshal is running
    """
    p = subprocess.run(["make", "log"], cwd="skyportal")
    if p.returncode != 0:
        raise RuntimeError("Failed to display fritz's logs")


def develop(args=None):
    """
    Install developer tools.
    """
    subprocess.run(["pip", "install", "-r", ".requirements/dev.txt"])
    subprocess.run(["pre-commit", "install"])


def lint(args):
    try:
        import pre_commit  # noqa: F401
    except ImportError:
        develop()

    subprocess.run(["pre-commit", "run", "--all-files"])


def test(args):
    print("Launching tests...")

    # load_demo_data is run as part of ./fritz run --init since it is needed to create a token for kowalski

    print("Testing Kowalski...")
    subprocess.run(["python", "kowalski.py", "test"], cwd="kowalski")


def doc(args):
    subprocess.run(["make", "html"], cwd="doc")
    Path("doc/_build/html/.nojekyll").touch()

    if args.upload:
        subprocess.run(
            [
                "./tools/push_dir_to_repo.py",
                "--branch",
                "master",
                "--committer",
                "fritz",
                "--email",
                "fritz@fritz-marshal.org",
                "--message",
                "Update website",
                "--force",
                "./doc/_build/html",
                "git@github.com:fritz-marshal/doc",
            ]
        )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title="commands", dest="command")

    commands = [
        ("run", "üöÄ Launch Fritz"),
        ("stop", "‚úã Shut Fritz down"),
        ("test", "Run the test suite"),
        ("develop", "Install tools for developing Fritz"),
        ("lint", "Lint the full code base"),
        ("prune", "‚ò†Ô∏è Wipe out containers, volumes, and submodules"),
        ("doc", "Build the documentation"),
        ("help", "Print this message"),
    ]

    parsers = {}
    for (cmd, desc) in commands:
        parsers[cmd] = subparsers.add_parser(cmd, help=desc)

    parsers["run"].add_argument(
        "--init", action="store_true", help="Initialize Fritz"
    )

    parsers["doc"].add_argument(
        "--upload", action="store_true", help="Upload documentation to GitHub"
    )

    args = parser.parse_args()
    if args.command is None or args.command == "help":
        parser.print_help()
    else:
        getattr(sys.modules[__name__], args.command)(args)
